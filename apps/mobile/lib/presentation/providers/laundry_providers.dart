import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../data/datasources/laundry_service_data_source.dart';
import '../../data/models/laundry_service_model.dart';

import '../../domain/entities/laundry_service.dart';

/// Provider for Supabase client
final supabaseClientProvider = Provider<SupabaseClient>((ref) {
  return Supabase.instance.client;
});

/// Provider for laundry service data source
final laundryServiceDataSourceProvider = Provider<LaundryServiceDataSource>((ref) {
  final supabaseClient = ref.watch(supabaseClientProvider);
  return LaundryServiceSupabaseDataSource(supabaseClient: supabaseClient);
});

/// Provider for fetching all laundry services
final laundryServicesProvider = FutureProvider<List<LaundryService>>((ref) async {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return await dataSource.getLaundryServices();
});

/// Provider for fetching a specific laundry service by ID
final laundryServiceByIdProvider = FutureProvider.family<LaundryService, String>((ref, serviceId) async {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return await dataSource.getLaundryServiceById(serviceId);
});

/// Provider for fetching user's laundry bookings
final userLaundryBookingsProvider = FutureProvider.family<List<LaundryBooking>, String>((ref, userId) async {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return await dataSource.getUserLaundryBookings(userId);
});

/// Provider for fetching a specific laundry booking by ID
final laundryBookingByIdProvider = FutureProvider.family<LaundryBooking, String>((ref, bookingId) async {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return await dataSource.getLaundryBookingById(bookingId);
});

/// Provider for calculating multi-service laundry price
final multiServicePriceCalculatorProvider = FutureProvider.family<double, List<MultiServicePriceItem>>((ref, items) async {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return await dataSource.calculateMultiServicePrice(items);
});

/// Provider for fetching available laundry vendors in an area
final availableLaundryVendorsProvider = FutureProvider.family<List<LaundryVendor>, String>((ref, area) async {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return await dataSource.getAvailableLaundryVendors(area);
});

/// State notifier for managing laundry booking creation
class LaundryBookingNotifier extends StateNotifier<AsyncValue<LaundryBooking?>> {
  final LaundryServiceDataSource _dataSource;

  LaundryBookingNotifier(this._dataSource) : super(const AsyncValue.data(null));

  /// Create a new multi-service laundry booking
  Future<void> createMultiServiceBooking(LaundryBookingModel booking, List<LaundryBookingItemModel> items) async {
    state = const AsyncValue.loading();
    try {
      final createdBooking = await _dataSource.createLaundryBooking(booking, items);
      state = AsyncValue.data(createdBooking);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Create a simplified booking (3-step flow without items)
  Future<void> createSimplifiedBooking({
    required String userId,
    required List<LaundryService> selectedServices,
    required DateTime pickupDate,
    required String pickupTimeSlot,
    required String pickupAddressId,
    String? specialInstructions,
  }) async {
    state = const AsyncValue.loading();

    // Validate input parameters
    if (selectedServices.isEmpty) {
      state = AsyncValue.error(
        Exception('At least one service must be selected'),
        StackTrace.current,
      );
      return;
    }

    if (userId.isEmpty) {
      state = AsyncValue.error(
        Exception('User authentication required'),
        StackTrace.current,
      );
      return;
    }

    try {
      // Create the main booking
      final booking = LaundryBookingModel(
        id: '', // Will be generated by database
        userId: userId,
        pickupAddressId: pickupAddressId,
        deliveryAddressId: pickupAddressId, // Same as pickup for laundry service
        pickupDate: pickupDate,
        pickupTimeSlot: pickupTimeSlot,
        totalEstimatedPrice: 0.0, // Will be calculated by vendor
        overallStatus: LaundryBookingStatus.pending,
        specialInstructions: specialInstructions,
        items: const [], // Will be populated after vendor assessment
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Create booking items for each selected service (without specific items)
      final bookingItems = selectedServices.map((service) {
        return LaundryBookingItemModel(
          id: '', // Will be generated by database
          bookingId: '', // Will be set by database
          serviceId: service.id,
          itemType: 'mixed', // Generic type for simplified booking
          quantity: 1, // Will be updated by vendor
          estimatedWeight: 0.0, // Will be assessed by vendor
          serviceBasePrice: service.basePrice,
          serviceTotalPrice: 0.0, // Will be calculated by vendor
          itemStatus: LaundryBookingItemStatus.pending,
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
      }).toList();

      // Attempt to create booking with retry logic
      LaundryBookingModel? createdBooking;
      int retryCount = 0;
      const maxRetries = 3;

      while (retryCount < maxRetries) {
        try {
          createdBooking = await _dataSource.createLaundryBooking(booking, bookingItems);
          break; // Success, exit retry loop
        } catch (e) {
          retryCount++;
          if (retryCount >= maxRetries) {
            rethrow; // Max retries reached, throw the error
          }

          // Wait before retrying (exponential backoff)
          await Future.delayed(Duration(seconds: retryCount * 2));
        }
      }

      if (createdBooking != null) {
        state = AsyncValue.data(createdBooking);
      } else {
        state = AsyncValue.error(
          Exception('Failed to create booking after $maxRetries attempts'),
          StackTrace.current,
        );
      }
    } catch (error, stackTrace) {
      // Log the error for debugging
      debugPrint('ðŸ§º BOOKING ERROR: $error');
      debugPrint('ðŸ§º STACK TRACE: $stackTrace');

      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Update an existing laundry booking
  Future<void> updateBooking(LaundryBookingModel booking) async {
    state = const AsyncValue.loading();
    try {
      final updatedBooking = await _dataSource.updateLaundryBooking(booking);
      state = AsyncValue.data(updatedBooking);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Cancel a laundry booking
  Future<void> cancelBooking(String bookingId) async {
    state = const AsyncValue.loading();
    try {
      final currentBooking = await _dataSource.getLaundryBookingById(bookingId);
      if (currentBooking.canBeCancelled) {
        final cancelledBooking = LaundryBookingModel(
          id: currentBooking.id,
          userId: currentBooking.userId,
          pickupAddressId: currentBooking.pickupAddressId,
          deliveryAddressId: currentBooking.deliveryAddressId,
          pickupDate: currentBooking.pickupDate,
          pickupTimeSlot: currentBooking.pickupTimeSlot,
          totalEstimatedPrice: currentBooking.totalEstimatedPrice,
          totalFinalPrice: currentBooking.totalFinalPrice,
          overallStatus: LaundryBookingStatus.cancelled,
          specialInstructions: currentBooking.specialInstructions,
          items: currentBooking.items,
          createdAt: currentBooking.createdAt,
          updatedAt: DateTime.now(),
        );

        final updatedBooking = await _dataSource.updateLaundryBooking(cancelledBooking);
        state = AsyncValue.data(updatedBooking);
      } else {
        throw Exception('Booking cannot be cancelled in current status');
      }
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }

  /// Reset the state
  void reset() {
    state = const AsyncValue.data(null);
  }
}

/// Provider for laundry booking notifier
final laundryBookingNotifierProvider = StateNotifierProvider<LaundryBookingNotifier, AsyncValue<LaundryBooking?>>((ref) {
  final dataSource = ref.watch(laundryServiceDataSourceProvider);
  return LaundryBookingNotifier(dataSource);
});

/// State notifier for managing multi-service laundry booking form
class LaundryBookingFormNotifier extends StateNotifier<LaundryBookingFormState> {
  LaundryBookingFormNotifier() : super(LaundryBookingFormState.initial());

  /// Add/remove service from selection
  void toggleService(LaundryService service) {
    final currentServices = List<LaundryService>.from(state.selectedServices);
    if (currentServices.any((s) => s.id == service.id)) {
      currentServices.removeWhere((s) => s.id == service.id);
      // Also remove items for this service
      final updatedServiceItems = Map<String, List<LaundryBookingItemData>>.from(state.serviceItems);
      updatedServiceItems.remove(service.id);
      state = state.copyWith(selectedServices: currentServices, serviceItems: updatedServiceItems);
    } else {
      currentServices.add(service);
      state = state.copyWith(selectedServices: currentServices);
    }
  }

  /// Update pickup address
  void updatePickupAddress(String addressId) {
    state = state.copyWith(pickupAddressId: addressId);
  }

  /// Update delivery address
  void updateDeliveryAddress(String addressId) {
    state = state.copyWith(deliveryAddressId: addressId);
  }

  /// Update pickup date and time
  void updatePickupDateTime(DateTime date, String timeSlot) {
    state = state.copyWith(
      pickupDate: date,
      pickupTimeSlot: timeSlot,
    );
  }

  /// Add item to specific service
  void addItemToService(String serviceId, LaundryBookingItemData item) {
    final updatedServiceItems = Map<String, List<LaundryBookingItemData>>.from(state.serviceItems);
    final currentItems = updatedServiceItems[serviceId] ?? [];
    updatedServiceItems[serviceId] = [...currentItems, item];
    state = state.copyWith(serviceItems: updatedServiceItems);
  }

  /// Remove item from specific service
  void removeItemFromService(String serviceId, int index) {
    final updatedServiceItems = Map<String, List<LaundryBookingItemData>>.from(state.serviceItems);
    final currentItems = List<LaundryBookingItemData>.from(updatedServiceItems[serviceId] ?? []);
    if (index < currentItems.length) {
      currentItems.removeAt(index);
      updatedServiceItems[serviceId] = currentItems;
      state = state.copyWith(serviceItems: updatedServiceItems);
    }
  }

  /// Update special instructions
  void updateSpecialInstructions(String instructions) {
    state = state.copyWith(specialInstructions: instructions);
  }

  /// Update total estimated price
  void updateTotalEstimatedPrice(double price) {
    state = state.copyWith(totalEstimatedPrice: price);
  }

  /// Reset form
  void reset() {
    state = LaundryBookingFormState.initial();
  }

  /// Check if form is valid
  bool get isValid {
    return state.selectedServices.isNotEmpty &&
           state.pickupDate != null &&
           state.pickupTimeSlot != null;
  }

  /// Get total items count across all services
  int get totalItemsCount {
    return state.serviceItems.values
        .expand((items) => items)
        .fold(0, (sum, item) => sum + item.quantity);
  }
}

/// Provider for laundry booking form notifier
final laundryBookingFormNotifierProvider = StateNotifierProvider<LaundryBookingFormNotifier, LaundryBookingFormState>((ref) {
  return LaundryBookingFormNotifier();
});

/// Data class for laundry booking item in form
class LaundryBookingItemData {
  final String itemType;
  final int quantity;
  final double estimatedWeight;
  final String? specialInstructions;

  LaundryBookingItemData({
    required this.itemType,
    required this.quantity,
    required this.estimatedWeight,
    this.specialInstructions,
  });
}

/// State class for multi-service laundry booking form
class LaundryBookingFormState {
  final List<LaundryService> selectedServices;
  final String? pickupAddressId;
  final String? deliveryAddressId;
  final DateTime? pickupDate;
  final String? pickupTimeSlot;
  final Map<String, List<LaundryBookingItemData>> serviceItems; // Items grouped by service ID
  final double? totalEstimatedPrice;
  final String? specialInstructions;

  LaundryBookingFormState({
    this.selectedServices = const [],
    this.pickupAddressId,
    this.deliveryAddressId,
    this.pickupDate,
    this.pickupTimeSlot,
    this.serviceItems = const {},
    this.totalEstimatedPrice,
    this.specialInstructions,
  });

  factory LaundryBookingFormState.initial() {
    return LaundryBookingFormState();
  }

  LaundryBookingFormState copyWith({
    List<LaundryService>? selectedServices,
    String? pickupAddressId,
    String? deliveryAddressId,
    DateTime? pickupDate,
    String? pickupTimeSlot,
    Map<String, List<LaundryBookingItemData>>? serviceItems,
    double? totalEstimatedPrice,
    String? specialInstructions,
  }) {
    return LaundryBookingFormState(
      selectedServices: selectedServices ?? this.selectedServices,
      pickupAddressId: pickupAddressId ?? this.pickupAddressId,
      deliveryAddressId: deliveryAddressId ?? this.deliveryAddressId,
      pickupDate: pickupDate ?? this.pickupDate,
      pickupTimeSlot: pickupTimeSlot ?? this.pickupTimeSlot,
      serviceItems: serviceItems ?? this.serviceItems,
      totalEstimatedPrice: totalEstimatedPrice ?? this.totalEstimatedPrice,
      specialInstructions: specialInstructions ?? this.specialInstructions,
    );
  }
}
